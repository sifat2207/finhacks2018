{
    "collab_server" : "",
    "contents" : "# ===================================================\n# Creating a SMOTE training sample for classification problems\n#\n# If called with learner=NULL (the default) is does not\n# learn any model, simply returning the SMOTEd data set\n#\n# NOTE: It does not handle NAs!\n#\n# Examples:\n#  library(DMwR)\n#  ms <- SMOTE(Species ~ .,iris,'setosa',perc.under=400,perc.over=300,\n#                learner='svm',gamma=0.001,cost=100)\n#  newds <- SMOTE(Species ~ .,iris,'setosa',perc.under=300,k=3,perc.over=400)\n#\n# L. Torgo, Feb 2010\n#\n# ===================================================\n# edit by sifat \n# the over sampling process is divide to continuous and non cintinous variables\n# https://www.analyticsvidhya.com/blog/2017/03/imbalanced-classification-problem/\n#\n# ---------------------------------------------------\nSMOTE <- function(form,data,\n                  perc.over=200,k=5,\n                  perc.under=200,\n                  learner=NULL,...\n)\n  \n  # INPUTS:\n  # form a model formula\n  # data the original training set (with the unbalanced distribution)\n  # minCl  the minority class label\n  # per.over/100 is the number of new cases (smoted cases) generated\n  #              for each rare case. If perc.over < 100 a single case\n  #              is generated uniquely for a randomly selected perc.over\n  #              of the rare cases\n  # k is the number of neighbours to consider as the pool from where\n  #   the new examples are generated\n# perc.under/100 is the number of \"normal\" cases that are randomly\n#                selected for each smoted case\n# learner the learning system to use.\n# ...  any learning parameters to pass to learner\n{\n  \n  # the column where the target variable is\n  tgt <- which(names(data) == as.character(form[[2]]))\n  minCl <- levels(data[,tgt])[which.min(table(data[,tgt]))]\n  \n  # get the cases of the minority class\n  minExs <- which(data[,tgt] == minCl)\n  \n  # generate synthetic cases from these minExs\n  if (tgt < ncol(data)) {\n    cols <- 1:ncol(data)\n    cols[c(tgt,ncol(data))] <- cols[c(ncol(data),tgt)]\n    data <-  data[,cols]\n  }\n  newExs <- smote.exs(data[minExs,],ncol(data),perc.over,k)\n  if (tgt < ncol(data)) {\n    newExs <- newExs[,cols]\n    data <- data[,cols]\n  }\n  \n  # get the undersample of the \"majority class\" examples\n  selMaj <- sample((1:NROW(data))[-minExs],\n                   as.integer((perc.under/100)*nrow(newExs)),\n                   replace=T)\n  \n  # the final data set (the undersample+the rare cases+the smoted exs)\n  newdataset <- rbind(data[selMaj,],data[minExs,],newExs)\n  \n  # learn a model if required\n  if (is.null(learner)) return(newdataset)\n  else do.call(learner,list(form,newdataset,...))\n}\n\n\n\n# ===================================================\n# Obtain a set of smoted examples for a set of rare cases.\n# L. Torgo, Feb 2010\n# ---------------------------------------------------\nsmote.exs <- function(data,tgt,N,k)\n  # INPUTS:\n  # data are the rare cases (the minority \"class\" cases)\n  # tgt is the name of the target variable\n  # N is the percentage of over-sampling to carry out;\n  # and k is the number of nearest neighours to use for the generation\n  # OUTPUTS:\n  # The result of the function is a (N/100)*T set of generated\n  # examples with rare values on the target\n{\n  nomatr <- c()\n  T <- matrix(nrow=dim(data)[1],ncol=dim(data)[2]-1)\n  for(col in seq.int(dim(T)[2]))\n    if (class(data[,col]) %in% c('factor','character')) {\n      T[,col] <- as.integer(data[,col])\n      nomatr <- c(nomatr,col)\n    } else T[,col] <- data[,col]\n  \n  if (N < 100) { # only a percentage of the T cases will be SMOTEd\n    nT <- NROW(T)\n    idx <- sample(1:nT,as.integer((N/100)*nT))\n    T <- T[idx,]\n    N <- 100\n  }\n  \n  p <- dim(T)[2]\n  nT <- dim(T)[1]\n  \n  ranges <- apply(T,2,max)-apply(T,2,min) # nilai max-min dari setiap variabel\n  \n  nexs <-  as.integer(N/100) # this is the number of artificial exs generated\n  # for each member of T\n  new <- matrix(nrow=nexs*nT,ncol=p)    # the new cases\n  \n  for(i in 1:nT) {\n    \n    # the k NNs of case T[i,]\n    xd <- scale(T,T[i,],ranges)\n    for(a in nomatr) xd[,a] <- xd[,a]==0\n    dd <- drop(xd^2 %*% rep(1, ncol(xd)))\n    kNNs <- order(dd)[2:(k+1)]\n    \n    for(n in 1:nexs) {\n      # select randomly one of the k NNs\n      neig <- sample(1:k,1)\n      \n      ex <- vector(length=ncol(T))\n      \n      # the attribute values of the generated case\n      difs <- T[kNNs[neig],]-T[i,]\n      new[(i-1)*nexs+n,] <- T[i,]+runif(1)*difs\n      for(a in nomatr)\n        new[(i-1)*nexs+n,a] <- c(T[kNNs[neig],a],T[i,a])[1+round(runif(1),0)]\n      \n    }\n  }\n  newCases <- data.frame(new)\n  for(a in nomatr)\n    newCases[,a] <- factor(newCases[,a],levels=1:nlevels(data[,a]),labels=levels(data[,a]))\n  \n  newCases[,tgt] <- factor(rep(data[1,tgt],nrow(newCases)),levels=levels(data[,tgt]))\n  colnames(newCases) <- colnames(data)\n  newCases\n}\n",
    "created" : 1536228756687.000,
    "dirty" : true,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "3996685180",
    "id" : "2282A617",
    "lastKnownWriteTime" : 1503901552,
    "last_content_update" : 1536412278631,
    "path" : "E:/Sifat/Amartha/Progress/ACILES/Update ACILES/CS/Amartha-r-cstrip-d2a75ea7b3ae/smote function.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}